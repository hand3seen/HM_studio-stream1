<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Headmosh Neon Network — Stream</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- p5 + p5.sound -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/addons/p5.sound.min.js"></script>
  <style>
    html,body{margin:0;height:100%;background:#000;font-family:ui-sans-serif,system-ui,Inter,Roboto,Arial}
    /* Clickable overlay link (top-left tag) */
    .pump-link{
      position:fixed;left:18px;top:18px;z-index:9;
      background:rgba(0,0,0,.55);backdrop-filter:blur(6px);
      border:1px solid rgba(255,255,255,.15);border-radius:12px;
      color:#e8f3ff;text-decoration:none;padding:10px 14px;font-size:14px;line-height:1;display:flex;gap:10px;align-items:center
    }
    .pump-dot{width:8px;height:8px;border-radius:50%;background:rgb(60,200,255);box-shadow:0 0 12px 4px rgba(60,200,255,.7)}
    .qr{display:none;position:absolute;left:0;top:44px;background:#000;border:1px solid rgba(255,255,255,.15);border-radius:8px;padding:8px}
    .pump-link:hover .qr{display:block}
    /* Fallback note for mic permission */
    #mic-hint{position:fixed;right:18px;top:18px;color:#cde;z-index:9;font-size:12px;background:rgba(0,0,0,.5);padding:8px 10px;border-radius:10px;border:1px solid rgba(255,255,255,.12)}
  </style>
</head>
<body>
  <!-- EDIT THESE TWO VALUES -->
  <a id="coinUrl" class="pump-link" target="_blank" rel="noreferrer">
    <span class="pump-dot"></span>
    <span id="coinText">pump.fun/coin/4QCQAkcKiYPnFWsSgGMuGeQdnrAmCKcNJkd2dm59pump</span>
    <!-- Optional QR via quick API (hover to show). Remove if you don’t want external calls. -->
    <img class="qr" id="qr" alt="QR" />
  </a>
  <div id="mic-hint">Press <b>M</b> to (re)enable mic audio-reactivity</div>

<script>
/* ===============================
   Headmosh Neon Network — v2
   Todd-ready: audio-reactive, countdown, ticker, one-file
   Keys:
   [M] mic on/off   [A] attract/repel
   [B] bloom        [N] palette
   [L] logo         [G] toggle giveaway panel
   [S] snapshot     [R] reset particles
=============================== */

const CONFIG = {
  particleDensity: 0.12,         // particles per px of width (0.12 ≈ 12% of width)
  maxSpeed: 1.35,
  connectRadius: 190,
  trailAlpha: 42,
  bloomPasses: 2,
  showLogo: true,
  showGiveaway: true,
  bannerTitle: "HEADMOSH STUDIO",
  bannerSub: "Go Head-First.",
  coinURL: "https://pump.fun/coin/4QCQAkcKiYPnFWsSgGMuGeQdnrAmCKcNJkd2dm59pump",
  // hourly giveaway resets every :00 (local time)
};

let particles = [];
let pg;              // offscreen buffer
let t = 0;
let attract = true;
let bloom = true;
let palettes, paletteIndex = 0;

// Audio
let mic, fft;
let audioEnabled = false;
let energy = 0; // smoothed 0..1 for visuals

// Ticker state
let tickerMsg = "Headmosh Zine Lab • Draw. Fold. Ship. • Live on PumpFun now • !headmosh •";
let tickerX = 0;

// URL params to override config
(function initParams(){
  const params = new URLSearchParams(location.search);
  if (params.get('title')) CONFIG.bannerTitle = params.get('title');
  if (params.get('sub')) CONFIG.bannerSub = params.get('sub');
  if (params.get('coin')) CONFIG.coinURL = params.get('coin');
})();

// Pump link + QR
const linkEl = document.getElementById('coinUrl');
const textEl = document.getElementById('coinText');
const qrEl = document.getElementById('qr');
textEl.textContent = CONFIG.coinURL.replace(/^https?:\/\//,'');
linkEl.href = CONFIG.coinURL;
// light QR (external) — comment out if you want purely offline
qrEl.src = "https://api.qrserver.com/v1/create-qr-code/?size=120x120&data="+encodeURIComponent(CONFIG.coinURL);

class Particle {
  constructor(){
    this.x = random(width);
    this.y = random(height);
    this.vx = random(-CONFIG.maxSpeed, CONFIG.maxSpeed);
    this.vy = random(-CONFIG.maxSpeed, CONFIG.maxSpeed);
  }
  move(){
    // audio-reactive noise field
    const ang = noise(this.x*0.001, this.y*0.001, t*0.0006) * TAU * (1.2 + energy*0.8);
    this.vx += cos(ang) * (0.025 + energy*0.045);
    this.vy += sin(ang) * (0.025 + energy*0.045);

    // mouse influence
    if (mouseX>=0 && mouseY>=0 && mouseX<=width && mouseY<=height){
      const dx = mouseX - this.x, dy = mouseY - this.y;
      const d2 = dx*dx + dy*dy;
      const force = constrain(40000/(d2+1500),0,0.18);
      const s = attract ? 1 : -1;
      this.vx += s*dx*force*0.0025;
      this.vy += s*dy*force*0.0025;
    }

    // speed cap
    const sp = sqrt(this.vx*this.vx + this.vy*this.vy);
    if (sp > CONFIG.maxSpeed){
      this.vx = (this.vx/sp)*CONFIG.maxSpeed;
      this.vy = (this.vy/sp)*CONFIG.maxSpeed;
    }

    this.x += this.vx;
    this.y += this.vy;

    // soft wrap
    if (this.x < -12) this.x = width+12;
    if (this.x > width+12) this.x = -12;
    if (this.y < -12) this.y = height+12;
    if (this.y > height+12) this.y = -12;
  }
  dot(g){
    g.noStroke();
    g.fill(255, 235);
    g.circle(this.x, this.y, 2.4 + energy*0.8);
  }
  connect(g, others){
    const cols = palettes[paletteIndex];
    for (let i=0;i<others.length;i++){
      const p = others[i];
      const dx = this.x - p.x, dy = this.y - p.y;
      const d = sqrt(dx*dx + dy*dy);
      if (d < CONFIG.connectRadius){
        const w = map(d, 0, CONFIG.connectRadius, 2.1 + energy*1.4, 0.2);
        const a = map(d, 0, CONFIG.connectRadius, 230, 110);
        const c = cols[floor(map(d,0,CONFIG.connectRadius,0,cols.length))%cols.length];

        g.stroke(c[0], c[1], c[2], a);
        g.strokeWeight(w);

        // curved wire + slight jitter for “live” feel
        const mx = (this.x + p.x)/2 + sin((this.x+t)*0.01)*6*(1+energy);
        const my = (this.y + p.y)/2 + cos((this.y+t)*0.01)*6*(1+energy);
        g.noFill();
        g.beginShape();
        g.curveVertex(this.x, this.y);
        g.curveVertex(this.x, this.y);
        g.curveVertex(mx, my);
        g.curveVertex(p.x, p.y);
        g.curveVertex(p.x, p.y);
        g.endShape();
      }
    }
  }
}

function setup(){
  pixelDensity(1);
  createCanvas(windowWidth, windowHeight);
  pg = createGraphics(width, height);

  palettes = [
    [ [10,240,255], [180,90,255], [255,80,180], [255,210,60] ],
    [ [90,200,255], [90,255,160], [255,120,120], [250,250,180] ],
    [ [255,100,40], [255,220,40], [80,220,255], [120,120,255] ],
    [ [140,255,220], [255,80,140], [110,150,255], [255,220,160] ],
  ];

  initParticles();
  pg.background(0);

  // Audio init deferred until user presses M (browser policy)
  fft = new p5.FFT(0.8, 512);

  // Make the link overlay track safe-area on resize
  positionLink();
}

function positionLink(){
  // Nothing required; CSS handles it, but keep for future safe-areas if desired
}

function initParticles(){
  particles.length = 0;
  const count = floor(width * CONFIG.particleDensity);
  for (let i=0;i<count;i++) particles.push(new Particle());
}

function drawBackground(g){
  // Subtle animated radial haze
  const cx = width*0.5 + sin(t*0.001)*66;
  const cy = height*0.5 + cos(t*0.0012)*50;
  for (let r = max(width,height); r>0; r -= 4){
    const k = map(r, 0, max(width,height), 0, 1);
    const v = 8 + 20*(1-k)*(0.5+0.5*sin(t*0.002+energy*2.0));
    g.noStroke();
    g.fill(v, v*0.8, v*0.9, 14);
    g.circle(cx, cy, r*2);
  }
}

function draw(){
  t++;

  // Audio energy 0..1
  let e = 0;
  if (audioEnabled){
    const spec = fft.analyze();
    const bass = fft.getEnergy(20, 140);
    const mid = fft.getEnergy(140, 1200);
    const high = fft.getEnergy(1200, 8000);
    e = (bass*0.55 + mid*0.35 + high*0.10) / 255;
  }
  // smooth
  energy = lerp(energy, e, 0.12);

  // Trails fade
  pg.noStroke();
  pg.fill(0, CONFIG.trailAlpha);
  pg.rect(0,0,width,height);

  drawBackground(pg);

  // Update + draw particles
  for (let p of particles) p.move();
  for (let i=0;i<particles.length;i++){
    const p = particles[i];
    p.dot(pg);
    p.connect(pg, particles.slice(i+1));
  }

  // Base pass
  image(pg, 0, 0);

  // Bloom (screen)
  if (bloom){
    push();
    drawingContext.globalCompositeOperation = 'screen';
    for (let i=0;i<CONFIG.bloomPasses;i++) image(pg, 0, 0);
    pop();
  }

  // Overlays
  scanlines();
  drawBanner();
  drawTicker();
  if (CONFIG.showGiveaway) drawGiveawayPanel();
}

function scanlines(){
  stroke(255, 8);
  strokeWeight(1);
  for (let y=0; y<height; y+=3) line(0,y,width,y);
}

function drawBanner(){
  if (!CONFIG.showLogo) return;
  const title = CONFIG.bannerTitle;
  const sub = CONFIG.bannerSub;
  const jx = (noise(t*0.02)-0.5)*2.0;

  push();
  textAlign(LEFT, TOP);
  noStroke();
  fill(0, 170);
  const padW = 330;
  textSize(42);
  const w = textWidth(title) + padW;
  rect(18, 72, w, 84, 16);

  // “glitchy” passes
  for (let i=3;i>=0;i--){
    fill(255, 255, 255, 50 - i*10);
    text(title, 36 + jx + i*0.8, 88 + i*0.8);
  }
  fill(255);
  text(title, 36 + jx, 88);

  textSize(18);
  fill(220);
  text(sub, 36, 124);
  pop();
}

function drawTicker(){
  // Scroll a simple text ticker along bottom
  const msg = tickerMsg + "  ";
  textSize(16);
  const tw = textWidth(msg);
  tickerX -= 2 + energy*4; // faster with energy
  if (tickerX < -tw) tickerX += tw;
  noStroke();
  fill(0,140);
  rect(0, height-40, width, 40);
  fill(230);
  textAlign(LEFT, CENTER);
  text(msg, tickerX, height-20);
  // clone pass for seamless loop
  text(msg, tickerX + tw, height-20);
}

function drawGiveawayPanel(){
  // Countdown to next hour
  const now = new Date();
  const nextHour = new Date(now);
  nextHour.setMinutes(0,0,0);
  if (nextHour <= now) nextHour.setHours(nextHour.getHours()+1);
  const ms = nextHour - now;
  const sec = Math.floor(ms/1000)%60;
  const min = Math.floor(ms/60000);

  const label = "Giveaway in";
  const timeStr = nf(min,2) + ":" + nf(sec,2);

  const w = 210, h = 86;
  const x = width - w - 18, y = 18;

  noStroke();
  fill(0,150);
  rect(x, y, w, h, 14);
  fill(200,230,255);
  textAlign(CENTER,CENTER);
  textSize(14);
  text(label, x+w/2, y+24);
  textSize(32);
  fill(255);
  text(timeStr, x+w/2, y+56);
}

function keyPressed(){
  if (key==='M' || key==='m') toggleMic();
  if (key==='A' || key==='a') attract = !attract;
  if (key==='B' || key==='b') bloom = !bloom;
  if (key==='N' || key==='n') paletteIndex = (paletteIndex+1)%palettes.length;
  if (key==='L' || key==='l') CONFIG.showLogo = !CONFIG.showLogo;
  if (key==='G' || key==='g') CONFIG.showGiveaway = !CONFIG.showGiveaway;
  if (key==='S' || key==='s') saveCanvas('headmosh-neon-network-v2','png');
  if (key==='R' || key==='r') initParticles();
}

function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
  pg = createGraphics(width, height);
  pg.background(0);
  initParticles();
}

// Mic / audio control
async function toggleMic(){
  try{
    if (!mic){
      mic = new p5.AudioIn();
    }
    if (!audioEnabled){
      await mic.start();
      fft.setInput(mic);
      audioEnabled = true;
      document.getElementById('mic-hint').style.display = 'none';
    } else {
      mic.stop();
      audioEnabled = false;
      document.getElementById('mic-hint').style.display = 'block';
    }
  } catch(e){
    console.warn('Mic error:', e);
    document.getElementById('mic-hint').textContent = 'Mic blocked — enable permissions or use OBS Audio Monitor. Press M to retry.';
  }
}
</script>
</body>
</html>
